// Code generated by mockery v2.46.3. DO NOT EDIT.

package log

import (
	context "context"

	log "github.com/rosaekapratama/go-starter/log"
	logrus "github.com/sirupsen/logrus"

	mock "github.com/stretchr/testify/mock"
)

// MockLogger is an autogenerated mock type for the Logger type
type MockLogger struct {
	mock.Mock
}

type MockLogger_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLogger) EXPECT() *MockLogger_Expecter {
	return &MockLogger_Expecter{mock: &_m.Mock}
}

// Debug provides a mock function with given fields: ctx, args
func (_m *MockLogger) Debug(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Debug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debug'
type MockLogger_Debug_Call struct {
	*mock.Call
}

// Debug is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Debug(ctx interface{}, args ...interface{}) *MockLogger_Debug_Call {
	return &MockLogger_Debug_Call{Call: _e.mock.On("Debug",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Debug_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Debug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Debug_Call) Return() *MockLogger_Debug_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Debug_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Debug_Call {
	_c.Call.Return(run)
	return _c
}

// Debugf provides a mock function with given fields: ctx, format, args
func (_m *MockLogger) Debugf(ctx context.Context, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Debugf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debugf'
type MockLogger_Debugf_Call struct {
	*mock.Call
}

// Debugf is a helper method to define mock.On call
//   - ctx context.Context
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Debugf(ctx interface{}, format interface{}, args ...interface{}) *MockLogger_Debugf_Call {
	return &MockLogger_Debugf_Call{Call: _e.mock.On("Debugf",
		append([]interface{}{ctx, format}, args...)...)}
}

func (_c *MockLogger_Debugf_Call) Run(run func(ctx context.Context, format string, args ...interface{})) *MockLogger_Debugf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Debugf_Call) Return() *MockLogger_Debugf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Debugf_Call) RunAndReturn(run func(context.Context, string, ...interface{})) *MockLogger_Debugf_Call {
	_c.Call.Return(run)
	return _c
}

// Debugln provides a mock function with given fields: ctx, args
func (_m *MockLogger) Debugln(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Debugln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Debugln'
type MockLogger_Debugln_Call struct {
	*mock.Call
}

// Debugln is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Debugln(ctx interface{}, args ...interface{}) *MockLogger_Debugln_Call {
	return &MockLogger_Debugln_Call{Call: _e.mock.On("Debugln",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Debugln_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Debugln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Debugln_Call) Return() *MockLogger_Debugln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Debugln_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Debugln_Call {
	_c.Call.Return(run)
	return _c
}

// Error provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Error(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Error_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Error'
type MockLogger_Error_Call struct {
	*mock.Call
}

// Error is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Error(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Error_Call {
	return &MockLogger_Error_Call{Call: _e.mock.On("Error",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Error_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Error_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Error_Call) Return() *MockLogger_Error_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Error_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Error_Call {
	_c.Call.Return(run)
	return _c
}

// Errorf provides a mock function with given fields: ctx, err, format, args
func (_m *MockLogger) Errorf(ctx context.Context, err error, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Errorf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Errorf'
type MockLogger_Errorf_Call struct {
	*mock.Call
}

// Errorf is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Errorf(ctx interface{}, err interface{}, format interface{}, args ...interface{}) *MockLogger_Errorf_Call {
	return &MockLogger_Errorf_Call{Call: _e.mock.On("Errorf",
		append([]interface{}{ctx, err, format}, args...)...)}
}

func (_c *MockLogger_Errorf_Call) Run(run func(ctx context.Context, err error, format string, args ...interface{})) *MockLogger_Errorf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Errorf_Call) Return() *MockLogger_Errorf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Errorf_Call) RunAndReturn(run func(context.Context, error, string, ...interface{})) *MockLogger_Errorf_Call {
	_c.Call.Return(run)
	return _c
}

// Errorln provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Errorln(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Errorln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Errorln'
type MockLogger_Errorln_Call struct {
	*mock.Call
}

// Errorln is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Errorln(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Errorln_Call {
	return &MockLogger_Errorln_Call{Call: _e.mock.On("Errorln",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Errorln_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Errorln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Errorln_Call) Return() *MockLogger_Errorln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Errorln_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Errorln_Call {
	_c.Call.Return(run)
	return _c
}

// Fatal provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Fatal(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Fatal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fatal'
type MockLogger_Fatal_Call struct {
	*mock.Call
}

// Fatal is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Fatal(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Fatal_Call {
	return &MockLogger_Fatal_Call{Call: _e.mock.On("Fatal",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Fatal_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Fatal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Fatal_Call) Return() *MockLogger_Fatal_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Fatal_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Fatal_Call {
	_c.Call.Return(run)
	return _c
}

// Fatalf provides a mock function with given fields: ctx, err, format, args
func (_m *MockLogger) Fatalf(ctx context.Context, err error, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Fatalf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fatalf'
type MockLogger_Fatalf_Call struct {
	*mock.Call
}

// Fatalf is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Fatalf(ctx interface{}, err interface{}, format interface{}, args ...interface{}) *MockLogger_Fatalf_Call {
	return &MockLogger_Fatalf_Call{Call: _e.mock.On("Fatalf",
		append([]interface{}{ctx, err, format}, args...)...)}
}

func (_c *MockLogger_Fatalf_Call) Run(run func(ctx context.Context, err error, format string, args ...interface{})) *MockLogger_Fatalf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Fatalf_Call) Return() *MockLogger_Fatalf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Fatalf_Call) RunAndReturn(run func(context.Context, error, string, ...interface{})) *MockLogger_Fatalf_Call {
	_c.Call.Return(run)
	return _c
}

// Fatalln provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Fatalln(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Fatalln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Fatalln'
type MockLogger_Fatalln_Call struct {
	*mock.Call
}

// Fatalln is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Fatalln(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Fatalln_Call {
	return &MockLogger_Fatalln_Call{Call: _e.mock.On("Fatalln",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Fatalln_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Fatalln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Fatalln_Call) Return() *MockLogger_Fatalln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Fatalln_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Fatalln_Call {
	_c.Call.Return(run)
	return _c
}

// GetLevel provides a mock function with given fields:
func (_m *MockLogger) GetLevel() logrus.Level {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLevel")
	}

	var r0 logrus.Level
	if rf, ok := ret.Get(0).(func() logrus.Level); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(logrus.Level)
	}

	return r0
}

// MockLogger_GetLevel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLevel'
type MockLogger_GetLevel_Call struct {
	*mock.Call
}

// GetLevel is a helper method to define mock.On call
func (_e *MockLogger_Expecter) GetLevel() *MockLogger_GetLevel_Call {
	return &MockLogger_GetLevel_Call{Call: _e.mock.On("GetLevel")}
}

func (_c *MockLogger_GetLevel_Call) Run(run func()) *MockLogger_GetLevel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLogger_GetLevel_Call) Return(_a0 logrus.Level) *MockLogger_GetLevel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogger_GetLevel_Call) RunAndReturn(run func() logrus.Level) *MockLogger_GetLevel_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogrusLogger provides a mock function with given fields:
func (_m *MockLogger) GetLogrusLogger() logrus.Ext1FieldLogger {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLogrusLogger")
	}

	var r0 logrus.Ext1FieldLogger
	if rf, ok := ret.Get(0).(func() logrus.Ext1FieldLogger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logrus.Ext1FieldLogger)
		}
	}

	return r0
}

// MockLogger_GetLogrusLogger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogrusLogger'
type MockLogger_GetLogrusLogger_Call struct {
	*mock.Call
}

// GetLogrusLogger is a helper method to define mock.On call
func (_e *MockLogger_Expecter) GetLogrusLogger() *MockLogger_GetLogrusLogger_Call {
	return &MockLogger_GetLogrusLogger_Call{Call: _e.mock.On("GetLogrusLogger")}
}

func (_c *MockLogger_GetLogrusLogger_Call) Run(run func()) *MockLogger_GetLogrusLogger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLogger_GetLogrusLogger_Call) Return(_a0 logrus.Ext1FieldLogger) *MockLogger_GetLogrusLogger_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogger_GetLogrusLogger_Call) RunAndReturn(run func() logrus.Ext1FieldLogger) *MockLogger_GetLogrusLogger_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: ctx, args
func (_m *MockLogger) Info(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockLogger_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Info(ctx interface{}, args ...interface{}) *MockLogger_Info_Call {
	return &MockLogger_Info_Call{Call: _e.mock.On("Info",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Info_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Info_Call) Return() *MockLogger_Info_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Info_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Info_Call {
	_c.Call.Return(run)
	return _c
}

// Infof provides a mock function with given fields: ctx, format, args
func (_m *MockLogger) Infof(ctx context.Context, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Infof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Infof'
type MockLogger_Infof_Call struct {
	*mock.Call
}

// Infof is a helper method to define mock.On call
//   - ctx context.Context
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Infof(ctx interface{}, format interface{}, args ...interface{}) *MockLogger_Infof_Call {
	return &MockLogger_Infof_Call{Call: _e.mock.On("Infof",
		append([]interface{}{ctx, format}, args...)...)}
}

func (_c *MockLogger_Infof_Call) Run(run func(ctx context.Context, format string, args ...interface{})) *MockLogger_Infof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Infof_Call) Return() *MockLogger_Infof_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Infof_Call) RunAndReturn(run func(context.Context, string, ...interface{})) *MockLogger_Infof_Call {
	_c.Call.Return(run)
	return _c
}

// Infoln provides a mock function with given fields: ctx, args
func (_m *MockLogger) Infoln(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Infoln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Infoln'
type MockLogger_Infoln_Call struct {
	*mock.Call
}

// Infoln is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Infoln(ctx interface{}, args ...interface{}) *MockLogger_Infoln_Call {
	return &MockLogger_Infoln_Call{Call: _e.mock.On("Infoln",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Infoln_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Infoln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Infoln_Call) Return() *MockLogger_Infoln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Infoln_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Infoln_Call {
	_c.Call.Return(run)
	return _c
}

// Panic provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Panic(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Panic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Panic'
type MockLogger_Panic_Call struct {
	*mock.Call
}

// Panic is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Panic(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Panic_Call {
	return &MockLogger_Panic_Call{Call: _e.mock.On("Panic",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Panic_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Panic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Panic_Call) Return() *MockLogger_Panic_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Panic_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Panic_Call {
	_c.Call.Return(run)
	return _c
}

// Panicf provides a mock function with given fields: ctx, err, format, args
func (_m *MockLogger) Panicf(ctx context.Context, err error, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Panicf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Panicf'
type MockLogger_Panicf_Call struct {
	*mock.Call
}

// Panicf is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Panicf(ctx interface{}, err interface{}, format interface{}, args ...interface{}) *MockLogger_Panicf_Call {
	return &MockLogger_Panicf_Call{Call: _e.mock.On("Panicf",
		append([]interface{}{ctx, err, format}, args...)...)}
}

func (_c *MockLogger_Panicf_Call) Run(run func(ctx context.Context, err error, format string, args ...interface{})) *MockLogger_Panicf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Panicf_Call) Return() *MockLogger_Panicf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Panicf_Call) RunAndReturn(run func(context.Context, error, string, ...interface{})) *MockLogger_Panicf_Call {
	_c.Call.Return(run)
	return _c
}

// Panicln provides a mock function with given fields: ctx, err, args
func (_m *MockLogger) Panicln(ctx context.Context, err error, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, err)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Panicln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Panicln'
type MockLogger_Panicln_Call struct {
	*mock.Call
}

// Panicln is a helper method to define mock.On call
//   - ctx context.Context
//   - err error
//   - args ...interface{}
func (_e *MockLogger_Expecter) Panicln(ctx interface{}, err interface{}, args ...interface{}) *MockLogger_Panicln_Call {
	return &MockLogger_Panicln_Call{Call: _e.mock.On("Panicln",
		append([]interface{}{ctx, err}, args...)...)}
}

func (_c *MockLogger_Panicln_Call) Run(run func(ctx context.Context, err error, args ...interface{})) *MockLogger_Panicln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(error), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Panicln_Call) Return() *MockLogger_Panicln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Panicln_Call) RunAndReturn(run func(context.Context, error, ...interface{})) *MockLogger_Panicln_Call {
	_c.Call.Return(run)
	return _c
}

// Print provides a mock function with given fields: ctx, args
func (_m *MockLogger) Print(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Print_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Print'
type MockLogger_Print_Call struct {
	*mock.Call
}

// Print is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Print(ctx interface{}, args ...interface{}) *MockLogger_Print_Call {
	return &MockLogger_Print_Call{Call: _e.mock.On("Print",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Print_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Print_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Print_Call) Return() *MockLogger_Print_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Print_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Print_Call {
	_c.Call.Return(run)
	return _c
}

// Printf provides a mock function with given fields: ctx, format, args
func (_m *MockLogger) Printf(ctx context.Context, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Printf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Printf'
type MockLogger_Printf_Call struct {
	*mock.Call
}

// Printf is a helper method to define mock.On call
//   - ctx context.Context
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Printf(ctx interface{}, format interface{}, args ...interface{}) *MockLogger_Printf_Call {
	return &MockLogger_Printf_Call{Call: _e.mock.On("Printf",
		append([]interface{}{ctx, format}, args...)...)}
}

func (_c *MockLogger_Printf_Call) Run(run func(ctx context.Context, format string, args ...interface{})) *MockLogger_Printf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Printf_Call) Return() *MockLogger_Printf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Printf_Call) RunAndReturn(run func(context.Context, string, ...interface{})) *MockLogger_Printf_Call {
	_c.Call.Return(run)
	return _c
}

// Println provides a mock function with given fields: ctx, args
func (_m *MockLogger) Println(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Println_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Println'
type MockLogger_Println_Call struct {
	*mock.Call
}

// Println is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Println(ctx interface{}, args ...interface{}) *MockLogger_Println_Call {
	return &MockLogger_Println_Call{Call: _e.mock.On("Println",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Println_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Println_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Println_Call) Return() *MockLogger_Println_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Println_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Println_Call {
	_c.Call.Return(run)
	return _c
}

// Trace provides a mock function with given fields: ctx, args
func (_m *MockLogger) Trace(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Trace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Trace'
type MockLogger_Trace_Call struct {
	*mock.Call
}

// Trace is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Trace(ctx interface{}, args ...interface{}) *MockLogger_Trace_Call {
	return &MockLogger_Trace_Call{Call: _e.mock.On("Trace",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Trace_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Trace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Trace_Call) Return() *MockLogger_Trace_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Trace_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Trace_Call {
	_c.Call.Return(run)
	return _c
}

// Tracef provides a mock function with given fields: ctx, format, args
func (_m *MockLogger) Tracef(ctx context.Context, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Tracef_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tracef'
type MockLogger_Tracef_Call struct {
	*mock.Call
}

// Tracef is a helper method to define mock.On call
//   - ctx context.Context
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Tracef(ctx interface{}, format interface{}, args ...interface{}) *MockLogger_Tracef_Call {
	return &MockLogger_Tracef_Call{Call: _e.mock.On("Tracef",
		append([]interface{}{ctx, format}, args...)...)}
}

func (_c *MockLogger_Tracef_Call) Run(run func(ctx context.Context, format string, args ...interface{})) *MockLogger_Tracef_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Tracef_Call) Return() *MockLogger_Tracef_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Tracef_Call) RunAndReturn(run func(context.Context, string, ...interface{})) *MockLogger_Tracef_Call {
	_c.Call.Return(run)
	return _c
}

// Traceln provides a mock function with given fields: ctx, args
func (_m *MockLogger) Traceln(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Traceln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Traceln'
type MockLogger_Traceln_Call struct {
	*mock.Call
}

// Traceln is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Traceln(ctx interface{}, args ...interface{}) *MockLogger_Traceln_Call {
	return &MockLogger_Traceln_Call{Call: _e.mock.On("Traceln",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Traceln_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Traceln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Traceln_Call) Return() *MockLogger_Traceln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Traceln_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Traceln_Call {
	_c.Call.Return(run)
	return _c
}

// Warn provides a mock function with given fields: ctx, args
func (_m *MockLogger) Warn(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Warn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warn'
type MockLogger_Warn_Call struct {
	*mock.Call
}

// Warn is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Warn(ctx interface{}, args ...interface{}) *MockLogger_Warn_Call {
	return &MockLogger_Warn_Call{Call: _e.mock.On("Warn",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Warn_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Warn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Warn_Call) Return() *MockLogger_Warn_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Warn_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Warn_Call {
	_c.Call.Return(run)
	return _c
}

// Warnf provides a mock function with given fields: ctx, format, args
func (_m *MockLogger) Warnf(ctx context.Context, format string, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx, format)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Warnf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warnf'
type MockLogger_Warnf_Call struct {
	*mock.Call
}

// Warnf is a helper method to define mock.On call
//   - ctx context.Context
//   - format string
//   - args ...interface{}
func (_e *MockLogger_Expecter) Warnf(ctx interface{}, format interface{}, args ...interface{}) *MockLogger_Warnf_Call {
	return &MockLogger_Warnf_Call{Call: _e.mock.On("Warnf",
		append([]interface{}{ctx, format}, args...)...)}
}

func (_c *MockLogger_Warnf_Call) Run(run func(ctx context.Context, format string, args ...interface{})) *MockLogger_Warnf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Warnf_Call) Return() *MockLogger_Warnf_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Warnf_Call) RunAndReturn(run func(context.Context, string, ...interface{})) *MockLogger_Warnf_Call {
	_c.Call.Return(run)
	return _c
}

// Warnln provides a mock function with given fields: ctx, args
func (_m *MockLogger) Warnln(ctx context.Context, args ...interface{}) {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	_m.Called(_ca...)
}

// MockLogger_Warnln_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Warnln'
type MockLogger_Warnln_Call struct {
	*mock.Call
}

// Warnln is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockLogger_Expecter) Warnln(ctx interface{}, args ...interface{}) *MockLogger_Warnln_Call {
	return &MockLogger_Warnln_Call{Call: _e.mock.On("Warnln",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockLogger_Warnln_Call) Run(run func(ctx context.Context, args ...interface{})) *MockLogger_Warnln_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockLogger_Warnln_Call) Return() *MockLogger_Warnln_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLogger_Warnln_Call) RunAndReturn(run func(context.Context, ...interface{})) *MockLogger_Warnln_Call {
	_c.Call.Return(run)
	return _c
}

// WithField provides a mock function with given fields: key, value
func (_m *MockLogger) WithField(key string, value interface{}) log.Logger {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for WithField")
	}

	var r0 log.Logger
	if rf, ok := ret.Get(0).(func(string, interface{}) log.Logger); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(log.Logger)
		}
	}

	return r0
}

// MockLogger_WithField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithField'
type MockLogger_WithField_Call struct {
	*mock.Call
}

// WithField is a helper method to define mock.On call
//   - key string
//   - value interface{}
func (_e *MockLogger_Expecter) WithField(key interface{}, value interface{}) *MockLogger_WithField_Call {
	return &MockLogger_WithField_Call{Call: _e.mock.On("WithField", key, value)}
}

func (_c *MockLogger_WithField_Call) Run(run func(key string, value interface{})) *MockLogger_WithField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *MockLogger_WithField_Call) Return(_a0 log.Logger) *MockLogger_WithField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogger_WithField_Call) RunAndReturn(run func(string, interface{}) log.Logger) *MockLogger_WithField_Call {
	_c.Call.Return(run)
	return _c
}

// WithFields provides a mock function with given fields: fields
func (_m *MockLogger) WithFields(fields map[string]interface{}) log.Logger {
	ret := _m.Called(fields)

	if len(ret) == 0 {
		panic("no return value specified for WithFields")
	}

	var r0 log.Logger
	if rf, ok := ret.Get(0).(func(map[string]interface{}) log.Logger); ok {
		r0 = rf(fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(log.Logger)
		}
	}

	return r0
}

// MockLogger_WithFields_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithFields'
type MockLogger_WithFields_Call struct {
	*mock.Call
}

// WithFields is a helper method to define mock.On call
//   - fields map[string]interface{}
func (_e *MockLogger_Expecter) WithFields(fields interface{}) *MockLogger_WithFields_Call {
	return &MockLogger_WithFields_Call{Call: _e.mock.On("WithFields", fields)}
}

func (_c *MockLogger_WithFields_Call) Run(run func(fields map[string]interface{})) *MockLogger_WithFields_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(map[string]interface{}))
	})
	return _c
}

func (_c *MockLogger_WithFields_Call) Return(_a0 log.Logger) *MockLogger_WithFields_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogger_WithFields_Call) RunAndReturn(run func(map[string]interface{}) log.Logger) *MockLogger_WithFields_Call {
	_c.Call.Return(run)
	return _c
}

// WithTraceFields provides a mock function with given fields: ctx
func (_m *MockLogger) WithTraceFields(ctx context.Context) log.Logger {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WithTraceFields")
	}

	var r0 log.Logger
	if rf, ok := ret.Get(0).(func(context.Context) log.Logger); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(log.Logger)
		}
	}

	return r0
}

// MockLogger_WithTraceFields_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTraceFields'
type MockLogger_WithTraceFields_Call struct {
	*mock.Call
}

// WithTraceFields is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLogger_Expecter) WithTraceFields(ctx interface{}) *MockLogger_WithTraceFields_Call {
	return &MockLogger_WithTraceFields_Call{Call: _e.mock.On("WithTraceFields", ctx)}
}

func (_c *MockLogger_WithTraceFields_Call) Run(run func(ctx context.Context)) *MockLogger_WithTraceFields_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLogger_WithTraceFields_Call) Return(_a0 log.Logger) *MockLogger_WithTraceFields_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLogger_WithTraceFields_Call) RunAndReturn(run func(context.Context) log.Logger) *MockLogger_WithTraceFields_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLogger creates a new instance of MockLogger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLogger(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLogger {
	mock := &MockLogger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
